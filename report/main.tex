\documentclass{article}

\usepackage{graphicx}
\usepackage{multicol}
\usepackage{lipsum} 
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{listings}
\usepackage{minted}
\usepackage{tikz}
\usepackage{tocloft}


\usepackage[margin=1.3in]{geometry}
\hypersetup{
    colorlinks=true,
    linkcolor=magenta, 
    filecolor=magenta,
    urlcolor=magenta,
}


\newenvironment{summary}{%
  \section*{Summary}
}{
}


\begin{document}

\begin{minipage}{.90\textwidth}
    \begin{center}
    \Large
    \textbf{Hybrid EIP-712 Verification Testing Methodology}

    \vspace{0.5cm}

    \Large
    October 29, 2025\\
    Shaun Miller (mourning\_dove)
    \end{center}

    \vspace{1cm} 
   
\textit{
  This testing methodology and all associated code snippets are provided \textbf{for educational, research, and security audit purposes only}. 
  They are designed exclusively for use on \textbf{private, local, or isolated test environments} (e.g., local $\texttt{forked}$ instances, $\texttt{Foundry}$ chains, or $\texttt{Ganache}$) and \textbf{must not} be deployed on or used to interact with any public, mainnet, or production blockchain network. 
  Any unauthorized or illegal activity is strictly prohibited and not endorsed by this documentation.
}

\end{minipage}
 
\vspace{1cm} 


\input{subsections/summary.tex}

\vspace{0.7em}
\noindent\rule{\textwidth}{0.7pt}

\tableofcontents

\section{Off-Chain Signatures}
\label{sec:solidity-phase}
\subsection{EIP712 Signature}

\subsection{Signing in Ethers}

\section{On-Chain Verification}

Unit tests verify the core cryptographic and access control properties directly on-chain. 
Nothing should touch the javascript yet.
We will do something a little more complicated with call data for the hybrid tests.
Here we will just run through how to verify in foundry.
Key tests include:
\begin{enumerate}
    \item \textbf{Digest Fidelity:} Asserting that the contract's computed $\texttt{EIP}$-$\texttt{712}$ digest matches the expected digest generated by a trusted off-chain utility.
    \item \textbf{Expired Deadline:} Ensuring a valid signature is rejected if the \texttt{deadline} is in the past.
    \item \textbf{Replay Protection:} Verifying the \texttt{nonce} mechanism correctly prevents reuse of a previously consumed signature.
    \item \textbf{Domain Separation:} Verifying that modifying the \texttt{chainId} or \texttt{verifyingContract} (address of \texttt{SignedVault}) invalidates the signature.
\end{enumerate}

\section{Hybrid Testing}
\label{sec:hybrid-phase}

\subsection{Simple Smart Contract that Checks signature}
Here we create and deploy a smart contract that verifies the user signature.

\subsection{Calldata Generation}
A critical weakness in $\texttt{EIP}$-$\texttt{712}$ systems is the mismatch between off-chain signing libraries and on-chain verification logic. 
This phase uses a \texttt{JavaScript} test harness to simulate a real user signing a message.
Here we go through a test that generates data, signs the data, and produces the call data all in JavaScript.
Foundry will call this script and use the calldata to input into our contract that checks the signature.

\subsection{Hybrid Test Integration}

The $\texttt{Foundry}$ test suite incorporates a custom external script call to the \texttt{JavaScript} environment.
\begin{itemize}
    \item \textbf{Setup:} The $\texttt{Foundry}$ test creates the necessary \texttt{Transfer} struct and passes the raw data to the \texttt{JavaScript} harness via a specific command-line call.
    \item \textbf{Execution:} The \texttt{JavaScript} environment signs the data and outputs the resulting $\texttt{R}$, $\texttt{S}$, $\texttt{V}$ signature as a hex string to $\texttt{stdout}$.
    \item \textbf{Verification:} The $\texttt{Foundry}$ test captures the signature from $\texttt{stdout}$ and uses it in the \texttt{SignedVault.verify} function, ensuring the full end-to-end flow is validated.
\end{itemize}

\section{Fuzz Testing}
Maybe we will comeback to fuzz testing.

\section{Conclusion}


\end{document}
